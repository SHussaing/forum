package main

import (
    "context"
    "database/sql"
    "fmt"
    "log"
    "net/http"
    "time"

    "github.com/google/uuid"
    _ "github.com/mattn/go-sqlite3"
    "golang.org/x/crypto/bcrypt"
)

var db *sql.DB

func init() {
    var err error
    db, err = sql.Open("sqlite3", "Database/ForumDatabase.db")
    if err != nil {
        log.Fatal(err)
    }

    // Ensure the sessions table is created
    createSessionsTableSQL := `
    CREATE TABLE IF NOT EXISTS Sessions (
        session_id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_ID INTEGER NOT NULL,
        token TEXT NOT NULL,
        expires_at DATETIME NOT NULL,
        FOREIGN KEY (user_ID) REFERENCES User(user_ID)
    );`
    _, err = db.Exec(createSessionsTableSQL)
    if err != nil {
        log.Fatal(err)
    }
}

func generateSessionToken() (string, error) {
    return uuid.New().String(), nil
}

func loginHandler(w http.ResponseWriter, r *http.Request) {
    email := r.FormValue("email")
    password := r.FormValue("password")

    // Validate user credentials
    var userID int
    var storedPassword string
    err := db.QueryRow("SELECT user_ID, password FROM User WHERE email = ?", email).Scan(&userID, &storedPassword)
    if err != nil {
        http.Error(w, "Invalid email or password", http.StatusUnauthorized)
        return
    }

    // Compare the stored password with the provided password
    if err := bcrypt.CompareHashAndPassword([]byte(storedPassword), []byte(password)); err != nil {
        http.Error(w, "Invalid email or password", http.StatusUnauthorized)
        return
    }

    // Generate a session token
    token, err := generateSessionToken()
    if err != nil {
        http.Error(w, "Internal server error", http.StatusInternalServerError)
        return
    }

    // Set session expiration (e.g., 24 hours)
    expiresAt := time.Now().Add(24 * time.Hour)

    // Delete any existing sessions for this user
    _, err = db.Exec("DELETE FROM Sessions WHERE user_ID = ?", userID)
    if err != nil {
        http.Error(w, "Internal server error", http.StatusInternalServerError)
        return
    }

    // Store the session in the database
    _, err = db.Exec("INSERT INTO Sessions (user_ID, token, expires_at) VALUES (?, ?, ?)", userID, token, expiresAt)
    if err != nil {
        http.Error(w, "Internal server error", http.StatusInternalServerError)
        return
    }

    // Set the session token as a cookie
    http.SetCookie(w, &http.Cookie{
        Name:    "session_token",
        Value:   token,
        Expires: expiresAt,
        Path:    "/",
    })

    // Redirect to a protected page
    http.Redirect(w, r, "/protected", http.StatusFound)
}

func sessionMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        cookie, err := r.Cookie("session_token")
        if err != nil {
            http.Redirect(w, r, "/login", http.StatusFound)
            return
        }

        var userID int
        var expiresAt time.Time
        err = db.QueryRow("SELECT user_ID, expires_at FROM Sessions WHERE token = ?", cookie.Value).Scan(&userID, &expiresAt)
        if err != nil || time.Now().After(expiresAt) {
            http.Redirect(w, r, "/login", http.StatusFound)
            return
        }

        // Add user ID to context
        ctx := context.WithValue(r.Context(), "userID", userID)
        next.ServeHTTP(w, r.WithContext(ctx))
    })
}

func logoutHandler(w http.ResponseWriter, r *http.Request) {
    cookie, err := r.Cookie("session_token")
    if err != nil {
        http.Redirect(w, r, "/login", http.StatusFound)
        return
    }

    _, err = db.Exec("DELETE FROM Sessions WHERE token = ?", cookie.Value)
    if err != nil {
        http.Error(w, "Internal server error", http.StatusInternalServerError)
        return
    }

    // Clear the cookie
    http.SetCookie(w, &http.Cookie{
        Name:   "session_token",
        Value:  "",
        MaxAge: -1,
        Path:   "/",
    })

    http.Redirect(w, r, "/login", http.StatusFound)
}

func main() {
    http.HandleFunc("/login", loginHandler)
    http.HandleFunc("/logout", logoutHandler)

    protected := http.NewServeMux()
    protected.HandleFunc("/protected", func(w http.ResponseWriter, r *http.Request) {
        userID := r.Context().Value("userID").(int)
        fmt.Fprintf(w, "Hello, user %d!", userID)
    })

    http.Handle("/protected", sessionMiddleware(protected))

    log.Fatal(http.ListenAndServe(":8080", nil))
}
